<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Learning to Code</title>
    <link rel="stylesheet" href="../index.css">
</head>
<body>
    <header>
        <div class=navigation>
            <a href="/index.html" class="button1">Home</a>
            <a href="/about.html" class="button2">About</a>
            <a href="/contact.html" class="button3">Contact</a>
        </div>
        <div class="name">
            <h1>Learning to Code</h1>
            <img src="/assets/logo.png" alt="logo" class="logo">
        </div>
    </header>
    <section class="post5">
        <div class="5">
            <h2>Humans Are The Weakest Link</h2>
            <p>I watched a lecture on cryptography the other day. Not realizing just how big of a number 2^256 is, I decided surely it can’t be that hard to make a program to solve for any random number between 0 and 115, 792, 089, 237, 316, 195, 423, 570, 985, 008, 687, 907, 853, 269, 984, 665, 640, 564, 039, 457, 584, 007, 913, 129, 639, 936. (This is what we call foreshadowing.)</p>
            <br>
            <p>Now, in all fairness, it is actually very simple to make a program to do <a href="https://github.com/Mark-DeLong/Passcode-Guesser"> that</a>.  This is 20 odd lines of C including brackets and whitespace.</p>
            <br>
            <p>The problem is, of course, that 2^256 is a stupidly huge number. Solving for every possible combination would take until the heat death of the universe, so even if you assume the average solve happens somewhere around the 50% mark, that still leaves billions of years to wait for an answer.</p>
            <br>
            <p>Even still, assuming someone who was actually good at math was doing this instead of myself who cannot add his way out of a paper bag, it is much easier to create a new cryptographic algorithm than it is to break it.</p>
            <br>
            <p>This finally gets us to optimization and the weakest link in any secure system: us humans. You may have noticed that my program doesn’t solve for 2^256 combinations, it solves for 55 trillion (~2^45.65 ). This is because while encryption uses obscenely large, fairly random numbers to protect data, systems are often protected by much less secure passcodes.</p>
            <br>
            <p>A standard American keyboard has about 92 unique keys. A-Z, a-z, 0-9, and a variety of special characters. So if instead of trying to solve a 256 digit passcode in binary, we instead try to solve a 7 digit passcode in base 92, we have ~55 trillion total possible combinations in base 10.</p>
            <br>
            <p>I did not make a custom dictionary for this program by design since I’m not trying to help people break into their ex lover’s Facebook. So basically, instead of passing through all 92 characters for 7 digits, it passes through 14 digits with 0-9 instead. The time it takes to solve is roughly the same, but the output is essentially worthless for anything other than learning purposes.</p>
            <br>
            <p>And all in all, the solve time is shockingly quick. With absolutely no optimization, it takes my shitty laptop 48 hours to attempt all possible combinations. But we’re not dealing with robots, we’re dealing with people, and people tend to act in predictable unrandom ways.</p>
            <br>
            <p>92^7 is all possible combinations, but how likely is someone to make their password “AAAAAAA”? In a true random system this is acceptable, but in a human system, this would never happen. Most people would only have 2 repeating digits in a row. So 92^7 becomes (92^2) * (91^2)*(90^2)*89, or reduction of 10%.</p>
            <br>
            <p>But that is just the tip of the iceberg. Of all the characters, some are almost certainly never used. Of “+_)(*&^%$#@!~`{}|[]\;’:”,./<>?”, some are certainly used since many websites require a special character, but how many are likely used? If we remove the characters “~`#$%^&*()_+-=[]\{}|;’:”,./<>” from the check, we reduce from 92 to characters to 63.</p>
            <br>
            <p>This brings us down to 3.9 trillion total combinations, or 3.4 trillion with a sequential character limit of 2, dropping the solve time down to 3.5-4 hours to check all possible combos. 

            <p>Is this a practical thing to do? No. But the point is to illustrate that we are the weakest link in our own security. If you’re just a dumb human like me, stop thinking that your unique password that you’ve been reusing for a decade is anything but a liability.</p>
            <br>
            <p>With 20 lines of code I could brute force any human likely password in a few hours. This is a reduction in security to 0.000000000000000000000000000000000000000 00000000000000000000000000002590850566528333% of what modern encryption offers.</p>
            <br>
            <p>So for the love of god, start using a password manager like lastpass that automatically generates long, unique passwords and syncs them across all your devices. This isn’t even as optimized as I could make it. This program just starts at zero and counts up, but I could easily reduce the solve time by another 99% by giving preference to characters over numbers and symbols, and starting with a dictionary of the most common human words and names.</p>
        </div>
    </section>
    <footer>
        <div class=navigation>
            <a href="/index.html" class="button1">Home</a>
            <a href="/about.html" class="button2">About</a>
            <a href="/contact.html" class="button3">Contact</a>
        </div>
    </footer>
</body>
</html>